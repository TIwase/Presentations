6 Elitist Multi-Objective EA

前章ではエリート戦略を使わないEAについて紹介
単目的最適化問題では，様々なエリート戦略GAが用いられている
4つの親子から優れている２つを選択し，次世代に残す
また，親集団と子集団を一緒くたにし，上位N個を選択して次世代に残す方法もある．

しかし，エリート戦略を導入してもグローバルベストの値は悪化しない．
→というのも，最良解を発見できなければ早い段階で収束してしまう傾向にある．
→この観点からはエリート戦略は必ずしも良いとは言えないじゃろう by Rudolph(1996)

以上より，本章ではエリート戦略の重要性を明らかにし，MOEAへ導入する重要性を明らかにする．
エリート戦略は実装が様々である．
ex. もし良い解を発見したとしても，今のパーソナルベスト解に留まり続けてしまう．

single-objective EAではベストな解αがエリートとして扱われるが，このアルゴリズムではそのαの価値が重要な役割を持つ．
パラメータαがむっちゃ小さいときは，エリートの利点は活用(exploit)されない．αは1から0.1N(Nは個体サイズ)である．

支配されていないものがベストな解になるのが理想的
→ 多目的最適化問題ではαは効かない

α=1というのはすべての支配されていない解をエリートとする
α=2は，全個体に対して初め２つの支配されていない解(rank1,2)をエリートとする
-------------------------------------------------------------------------------
6.1 Rudolph elitist MOEA

rudolphの提案したMOEAでは実装することができないが，MOEAにエリート戦略を用いることはできる．

一般的にμ個の親を使用してλ個の子を生成する．（親集団Pt, 個集団Qtとして）

-1st phase- 
Qtの最良解を照らし合わせる．子集合Qtから最良解を非支配解とし，Qtからいくつか削除してQ*に置き換える．
したがって，すべての解は少なくともQ*にある一つの解に支配される．
ex. 解a,b,eが非支配解となるとき，Qt={a,b,c,d,e,f}, → Q*={a,b,e} → Qt={c,d,f} P'=Q'=∅

-2nd phase- 
Q*の各解qが親集団Ptと交叉し，もしqがPtのある解を支配していたら，その解は削除される．
子が親の解を支配している間は，その解（子）をQ*からP'へ移動させる．
もしqが解を支配していなければqは非支配解としてPtにセットされる．qもまたP'の解より評価値が低い（少なくともPt内のいかなる会には支配されない）とき，Q*→Q'．
ex. q=aが4つの解D={1,2,3,4}を支配するとき，Ptからこれらの解を削除し，Pt={5,6}となり，P'={a}となる→Q*={b,e}
また，bは"6"を支配しているのでD(b)={6}，よってPt={5}，すなわちP'={a,b}→Q*={e}
"5"はbを支配しているが，本アルゴリズムではこれをカウントしない（ダメ絶対）．
よって，e及び"5"は非支配解となり，Q'={e}, Q*=∅

-3rd phase-
親集団P,P'を統合する．個体数が揃っていなかったら，Q',Q+から追加する．
→親と子の集団からベストな非支配解を選択し，(μ+λ)個の解をμ個に減らす
ex. 現在，Pt={5}, P'={a,b}, Q'={e}, Q*=∅, Qt={c,d,f} → Pt∨P'={5,a,b}
個体サイズを満たしてからQ'，次に他2つをQtから追加する（つまり，cとdを追加する）．
新しい集合はPt+1={5,a,b,c,d,e}
これは次の世代の親集合となる

このアルゴリズムの利点	パレート最適解が存在しなければ，
欠点	必ずしもパレート最適解に分布するとは限らない．一つのパレート最適解に収束してしまう可能性がある．
------------------------------------------------------------------
NSGA-II
-1st phase
親と子の集団を統合したRtを非優越ソートでランク付けする
-2nd phase
新しい集合Pt+1=∅を生成
Pt+1 + Fi < N となるまでPt+1 = Pt+1 ∨ Fi, i=i+1
-3rd phase
混雑度ソートFi < c を求め，Fiをランク付け．
-4th phase
親集団Pt+1から子集団Qt+1 を生成し，トーナメント選択によって交叉させる

■ 混雑トーナメント選択
1. 集合の非支配ランクriを決める
2. 集合の混雑距離diを算出
definition 1:
1. もし解iが良いランクであるならri < rj
2. もし同じランクを持つ解同士であったならri=rj(ただし，di > djとする)
混雑距離を算出する方法は様々で，ニッチカウントnciやヘッドカウントhciなどがあるが，NSGA-IIではこれらを使用しない

■ 混雑距離
最近傍の解同士の距離を算出し，その平均を取る．diは小さいほど解が密集している．
Step1: はじめ，di=0, 
Step2: 目的関数fm(m=1,2,..,M)で各解iをソートする（ソートベクトル:Im=sort）
Step3: 以下の式で表される
